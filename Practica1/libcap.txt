Biblioteca Libpcap
Abrir un archivo pcap
Para abrir un archivo (traza) previamente capturado:

pcap_t *pcap_open_offline(const char *fname, char *errbuf);

Donde

fname es el nombre del archivo .pcap que se desea abrir.
En errbuf se guarda el mensaje de error, si procede.
La función nos devuelve el puntero al descriptor de archivo .pcap.
Ejemplo:  p=pcap_open_offline(“traza.pcap”, errbuf);

Abre para lectura el archivo traza.pcap. En caso de error, guarda el mensaje en la cadena errbuf.

Capturar de un interfaz
Para abrir un interfaz para captura:

pcap_t *pcap_open_live(const char *device, int snaplen,int promisc, int to_ms, char *errbuf);

Donde

device es el nombre de la interfaz que se quiere abrir (eth0, eth1...).
snaplen es la cantidad de bytes que se quieren guardar por cada paquete. Es útil cuando no nos interesa la carga útil del paquete y así reduciríamos el tamaño de la captura.
promisc indica si queremos abrirla en modo promiscuo (promisc=1) o no (promisc=0).
to_ms duración del timeout de lectura. Tiempo que se espera para leer varios paquetes en una misma transacción (polling).
En errbuf se guarda el mensaje de error, si procede.
La función nos devuelve el puntero al descriptor de archivo .pcap.
Para abrir una interfaz es necesario tener permisos de superusuario. En la VM facilitada simplemente debemos usar sudo seguido de la instrucción.

Ejemplo:  descr=pcap_open_live(“eth0”,BUFSIZ,0, 100, errbuf);

Abre la interfaz eth0 en modo no promiscuo, capturando el paquete en su totalidad, con un timeout de lectura de 100 ms. (puede que la VM le alerte sobre la imposibilidad de capturar tráfico de modo promiscuo en caso de modificar el tercer argumento, no es importante para la realización de las prácticas, acepte y continúe).  En caso de error, guarda el mensaje en la cadena errbuf.

Leer tráfico de archivo o interfaz
int pcap_loop(pcap_t *descr, int cnt, pcap_handler callback, u_char *user);
Donde:

descr es el puntero a descriptor de archivo del que queramos leer (que anteriormente hemos abierto con open_pcap_live o open_pcap_offline).
cnt es el número de paquetes a analizar (-1 para ilimitados).
callback es un puntero a la función de atención al paquete.
user es un puntero auxiliar para comunicación con la función de atención.
pcap_loop nos devuelve:
0 si se leyó la tarza entera o se supero el límite cnt.
-1 Si hubo errores
-2 Si fue interrumpido por pcap_breakloop() (u otras).
Otros valores si se capturó un paquete.
Ejemplo:  ret = pcap_loop (descr,-1,f_nuevo_paquete, NULL);



Y a su vez: callback (u_char *user,const struct pcap_pkthdr* pkt_header,const u_char* pkt_data);

Donde:
user es el puntero que pcap_loop pasa a la función de atención por cada paquete.
pkt_header es la cabecera pcap del paquete a ser rellenada. Esta cabecera es una estructura con cuatro campos:
pkt_header->ts.tv_sec, timestamp del paquete en segundos.
pkt_header->ts.tv_usec, timestamp del paquete en microsegundos.
pkt_header->len: longitud real del paquete.
pkt_header->caplen: longitud capturada del paquete. Esto es, el puntero que nos devuelve sólo contiene h->caplen bytes.
pkt_data es el puntero al inicio del paquete leído en caso de éxito.
Es responsabilidad de pcap_loop(·), no de la función de atención, reservar y liberar la memoria para devolver la cabecera y datos de cada paquete.

Hay otras funciones para leer paquetes no basadas en bucles, del tipo pcap_next_ex(·)/pcap_next(·). No las use de ninguna manera en las prácticas. Los motivos son de tipo docente. Su uso conllevará una evaluación nula.


Guardar archivo pcap
Para guardar un archivo pcap necesitamos primero crear el archivo donde vamos a ir volcando los paquetes. Para ello se usan la funciones pcap_open_dead y pcap_dump_open:

pcap_t *pcap_open_dead(int linktype, int snaplen);

Donde

linktype es el tipo de enlace de los paquetes que vamos a guardar. Típicamente, redes Ethernet: DLT_EN10MB
snaplen es el tamaño máximo que queramos guardar de cada paquete.
Devuelve, como las otras funciones pcap_open, el puntero al descriptor de archivo pcap.

Ejemplo:  descr2=pcap_open_dead(DLT_EN10MB,1514);  Abre un descriptor de archivo pcap para paquetes Ethernet, guardando como máximo 1514 Bytes de cada paquete.

pcap_dumper_t * pcap_dump_open(pcap_t *descr, const char *fname);

Donde

descr es el descriptor de archivo pcap previamente abierto con pcap_open_dead.
fname es el nombre del archivo pcap en el que queramos guardar los paquetes.
Devuelve el puntero al archivo pcap donde se van a volcar los paquetes.

Ejemplos:  pdumper=pcap_dump_open(descr2,"salida.pcap");

Crea un archivo llamado salida.pcap con las características (tipo de enlace, y tamaño máximo de paquete) de descr2 (que indicamos en el pcap_open_dead). Nos devuelve el puntero a archivo de volcado de paquetes que vamos a utilizar para guardar los paquetes.  Para guardar paquetes en el archivo creado con pcap_dump_open usamos la función:  void pcap_dump(u_char *user, struct pcap_pkthdr *h,u_char *sp);

user es el puntero devuelto por pcap_dump_open.
h es un puntero a la cabecera pcap del paquete que vamos a guardar.
sp es el puntero al paquete. Se van a guardar tantos bytes como indiquemos en el campo caplen del parámetro h.
Ejemplo:  pcap_dump(pdumper,h,pkt_data);

Guardamos en pdumper el paquete apuntado por packet con cabecera h.

Cerrar archivo
Los descriptores abiertos con pcap_open_live, pcap_open_offline y pcap_open_dead se cierran con pcap_close(·).  Mientras que los archivos abiertos con pcap_dump_open se cierran con pcap_dump_close(·).

void pcap_close(pcap_t *descr);

Donde

descr es el descriptor a cerrar
void pcap_dump_close(pcap_dumper_t *descr);

descr es el descriptor a cerrar
Definición de tipos
Es muy importante trabajar con tipos sin signo con tamaño definido (uint8_t, uint16_t, uint32_t, etc... de stdint.h) con objeto de controlar su tamaño de forma precisa al realizar operaciones binarias.
